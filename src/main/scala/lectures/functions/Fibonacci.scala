package lectures.functions

/**
  * Цель упражнения, вычислить 9 - е число Фибоначчи
  * Для этого, раскомментируйте строчку в методе fibs и исправьте ошибку компиляции.
  *
  * Данная реализация вычисления чисел фибоначчи крайне не оптимальна (имеет показатеьную сложность O(a.pow(n)) )
  * Для того, что бы в этом убедиться Вы можете раскомментировать
  * строчку с вычислением 1000-ого числа фибоначчи
  *
  */
object Fibonacci extends App {

  // Task 2
  def fibs(num: Int): Int = {
    if (num == 1) 1
    else if (num == 2) 1
    else fibs(num - 1) + fibs(num - 2)
  }

  println(fibs(9))
  //println(fibs(1000))
}

/**
  * Цель упражнения, используя приемы динамического программирования
  * реаилзовать более оптимальный алгоритм подсчета чисел фибоначчи
  * Для этого нужно реализовать функцию fibsImpl.
  * Сигнатуру функции Вы можете расширять по своему усмотрению,
  * но реализация должна удовлетварять следующим требованиям
  * * * * метод fibsImpl - должен быть tail recursive
  * * * * параметр acc - аккумулятор посчитанных значений
  *
  */
object Fibonacci2 extends App {

  def fibs2(num: Int) =
    // В прошлой реализации числа начинаются с индекса 1
    // здесь же предполагалось почему-то, что c 0
    // так что здесь они тоже будут начинаться с индекса 1
    if (num <= 2) Array(0, 1, 1)(num)
    else fibsImpl(num, Array(0, 1, 1), 3)(num)

  private def fibsImpl(num: Int, acc: Array[Int], len: Int): Array[Int] = {
    if (num <= acc.length - 1) acc
    else fibsImpl(num, acc :+ (acc(len - 1) + acc(len - 2)), len + 1)
  }

  println(fibs2(16))
  //println(fibs2(1000))
}




